/* automatically generated by rust-bindgen 0.71.1 */

pub type Clp_Simplex = ::std::os::raw::c_void;
pub type clp_callback = ::std::option::Option<
    unsafe extern "C" fn(
        model: *mut Clp_Simplex,
        msgno: ::std::os::raw::c_int,
        ndouble: ::std::os::raw::c_int,
        dvec: *const f64,
        nint: ::std::os::raw::c_int,
        ivec: *const ::std::os::raw::c_int,
        nchar: ::std::os::raw::c_int,
        cvec: *mut *mut ::std::os::raw::c_char,
    ),
>;
pub type Sbb_Model = ::std::os::raw::c_void;
pub type Cbc_Model = ::std::os::raw::c_void;
#[doc = " typedef for user call back.\nThe cvec are constructed so don't need to be const"]
pub type sbb_callback = ::std::option::Option<
    unsafe extern "C" fn(
        model: *mut Sbb_Model,
        msgno: ::std::os::raw::c_int,
        ndouble: ::std::os::raw::c_int,
        dvec: *const f64,
        nint: ::std::os::raw::c_int,
        ivec: *const ::std::os::raw::c_int,
        nchar: ::std::os::raw::c_int,
        cvec: *mut *mut ::std::os::raw::c_char,
    ),
>;
pub type cbc_callback = ::std::option::Option<
    unsafe extern "C" fn(
        model: *mut Cbc_Model,
        msgno: ::std::os::raw::c_int,
        ndouble: ::std::os::raw::c_int,
        dvec: *const f64,
        nint: ::std::os::raw::c_int,
        ivec: *const ::std::os::raw::c_int,
        nchar: ::std::os::raw::c_int,
        cvec: *mut *mut ::std::os::raw::c_char,
    ),
>;
#[doc = " typedef for cbc cut callback osiSolver needs to be an OsiSolverInterface object,\n osiCuts is an OsiCuts object and appdata is a pointer that will be passed to the cut\n generation, you can use it to point to a data structure with information about the original problem,\n for instance"]
pub type cbc_cut_callback = ::std::option::Option<
    unsafe extern "C" fn(
        osiSolver: *mut ::std::os::raw::c_void,
        osiCuts: *mut ::std::os::raw::c_void,
        appdata: *mut ::std::os::raw::c_void,
    ),
>;
pub type CoinBigIndex = ::std::os::raw::c_int;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
unsafe extern "C" {
    #[doc = " Current version of Cbc"]
    pub fn Cbc_getVersion() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Creates an empty problem"]
    pub fn Cbc_newModel() -> *mut Cbc_Model;
}
unsafe extern "C" {
    #[doc = " @brief Sets problem name.\n\n @param model problem object\n @param array string with problem name"]
    pub fn Cbc_setProblemName(model: *mut Cbc_Model, array: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Creates a new column\n\n Creates a new column (variable)\n\n @param model problem object\n @param name variable name\n @param lb column lower bound\n @param ub column upper bound\n @param obj objective function coefficient\n @param isInteger 1 if variable is integral, 0 otherwise\n @param nz number of rows (constraints) where this column appears, can be 0 if constraints will be added later\n @param rows index of rows where this column appears, NULL if rows will be added later\n @param coefs coefficients that this column appears in its rows, NULL if rows will be added later"]
    pub fn Cbc_addCol(
        model: *mut Cbc_Model,
        name: *const ::std::os::raw::c_char,
        lb: f64,
        ub: f64,
        obj: f64,
        isInteger: ::std::os::raw::c_char,
        nz: ::std::os::raw::c_int,
        rows: *mut ::std::os::raw::c_int,
        coefs: *mut f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Adds a new row\n\n  Adds a new row (linear constraint) to the problem\n\n  @param model problem object\n  @param name constraint name\n  @param nz number of variables with non-zero coefficients in this row\n  @param cols index of variables that appear in this row\n  @param coefs cofficients that that variables appear\n  @param sense constraint sense: L if <=, G if >=, E if =, R if ranged and N if free\n  @param rhs right hand size"]
    pub fn Cbc_addRow(
        model: *mut Cbc_Model,
        name: *const ::std::os::raw::c_char,
        nz: ::std::os::raw::c_int,
        cols: *const ::std::os::raw::c_int,
        coefs: *const f64,
        sense: ::std::os::raw::c_char,
        rhs: f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Add SOS constraints to the model using row-order matrix"]
    pub fn Cbc_addSOS(
        model: *mut Cbc_Model,
        numRows: ::std::os::raw::c_int,
        rowStarts: *const ::std::os::raw::c_int,
        colIndices: *const ::std::os::raw::c_int,
        weights: *const f64,
        type_: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Loads a problem (the constraints on the\nrows are given by lower and upper bounds). If a pointer is NULL then the\nfollowing values are the default:\n<ul>\n<li> <code>colub</code>: all columns have upper bound infinity\n<li> <code>collb</code>: all columns have lower bound 0\n<li> <code>rowub</code>: all rows have upper bound infinity\n<li> <code>rowlb</code>: all rows have lower bound -infinity\n<li> <code>obj</code>: all variables have 0 objective coefficient\n</ul>\n\nThe constraint matrix is\ngiven in standard compressed sparse column (without gaps).\n<ul>\n<li> <code>start[i]</code> stores the starting index of the ith column\n<li> <code>index[k]</code> stores the row index of the kth nonzero element\n<li> <code>value[k]</code> stores the coefficient of the kth nonzero element\n</ul>"]
    pub fn Cbc_loadProblem(
        model: *mut Cbc_Model,
        numcols: ::std::os::raw::c_int,
        numrows: ::std::os::raw::c_int,
        start: *const CoinBigIndex,
        index: *const ::std::os::raw::c_int,
        value: *const f64,
        collb: *const f64,
        colub: *const f64,
        obj: *const f64,
        rowlb: *const f64,
        rowub: *const f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Set the name of a column\n\n @param model problem object\n @param iColumn column index\n @param column name"]
    pub fn Cbc_setColName(model: *mut Cbc_Model, iColumn: ::std::os::raw::c_int, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " @brief Set the name of a row\n\n @param model problem object\n @param iRow row index\n @param name row name"]
    pub fn Cbc_setRowName(model: *mut Cbc_Model, iRow: ::std::os::raw::c_int, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " @brief Sets optimization direction\n\n @param model problem object\n @param sense: direction of optimization (1 - minimize, -1 - maximize, 0 - ignore)"]
    pub fn Cbc_setObjSense(model: *mut Cbc_Model, sense: f64);
}
unsafe extern "C" {
    #[doc = " @brief Set the lower bound of a single constraint\n\n @param model problem object\n @param index row index\n @param value new row lower bound"]
    pub fn Cbc_setRowLower(model: *mut Cbc_Model, index: ::std::os::raw::c_int, value: f64);
}
unsafe extern "C" {
    #[doc = " @brief  Set the upper bound of a single constraint\n\n @param model problem object\n @param index row index\n @param value new row upper bound"]
    pub fn Cbc_setRowUpper(model: *mut Cbc_Model, index: ::std::os::raw::c_int, value: f64);
}
unsafe extern "C" {
    #[doc = " @brief Set the objective coefficient of a single variable\n\n @param model problem object\n @param index variable index\n @param value new objective function coefficient for this variable"]
    pub fn Cbc_setObjCoeff(model: *mut Cbc_Model, index: ::std::os::raw::c_int, value: f64);
}
unsafe extern "C" {
    #[doc = " @brief Set the lower bound of a single variable\n\n @param model problem object\n @param index variable index\n @param value variable lower bound"]
    pub fn Cbc_setColLower(model: *mut Cbc_Model, index: ::std::os::raw::c_int, value: f64);
}
unsafe extern "C" {
    #[doc = " @brief Set the upper bound of a single variable\n\n @param model problem object\n @param index variable index\n @param value new variable upper bound"]
    pub fn Cbc_setColUpper(model: *mut Cbc_Model, index: ::std::os::raw::c_int, value: f64);
}
unsafe extern "C" {
    #[doc = " @brief Set this variable to be continuous\n\n @param model problem object\n @param iColumn column index"]
    pub fn Cbc_setContinuous(model: *mut Cbc_Model, iColumn: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Set this variable to be integer\n\n @param model problem object\n @param iColumn column index"]
    pub fn Cbc_setInteger(model: *mut Cbc_Model, iColumn: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Cbc_Model destructor"]
    pub fn Cbc_deleteModel(model: *mut Cbc_Model);
}
unsafe extern "C" {
    #[doc = " @brief Enter initial feasible solution\n\n Enter an initial feasible solution. Only the non-zero main\n binary/integer decision variables need to be informed.\n Auxiliary and/or continuous variables are computed\n automatically.\n\n @param model problem object\n @param count number of variables\n @param colNames names of variables\n @param colValues variable values\n"]
    pub fn Cbc_setMIPStart(
        model: *mut Cbc_Model,
        count: ::std::os::raw::c_int,
        colNames: *mut *const ::std::os::raw::c_char,
        colValues: *const f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Enter initial feasible solution\n\n Enter an initial feasible solution. Only the non-zero main\n binary/integer decision variables need to be informed.\n Auxiliary and/or continuous variables are computed\n automatically. Same as setMIPStart but using variable indexes.\n\n @param model problem object\n @param count number of variables\n @param colIdxs indexes of variables\n @param colValues variable values\n"]
    pub fn Cbc_setMIPStartI(
        model: *mut Cbc_Model,
        count: ::std::os::raw::c_int,
        colIdxs: *const ::std::os::raw::c_int,
        colValues: *const f64,
    );
}
unsafe extern "C" {
    #[doc = " @brief Creates a copy of the current model\n\n @param model problem object\n @return model copy"]
    pub fn Cbc_clone(model: *mut Cbc_Model) -> *mut Cbc_Model;
}
unsafe extern "C" {
    #[doc = " @brief Queries problem name\n\n @param model problem object\n @param maxNumberCharacters space in string array\n @param array string where problem name will be saved"]
    pub fn Cbc_problemName(
        model: *mut Cbc_Model,
        maxNumberCharacters: ::std::os::raw::c_int,
        array: *mut ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " @brief Number of nonzero elements in constraint matrix\n\n @param model problem object\n @return number of non-zero entries in constraint matrix"]
    pub fn Cbc_getNumElements(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Number of variables in the model\n @param model problem object\n @return number of columns (variables)"]
    pub fn Cbc_getNumCols(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Number of integer variables in the model\n\n @param model problem object\n @return number of integer variables in this model"]
    pub fn Cbc_getNumIntegers(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Number of constraints in the model\n @param model problem object\n @return number of rows (constraints) in the model"]
    pub fn Cbc_getNumRows(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Queries row name\n\n @param model problem object\n @param row index\n @param name string where row name will be stored\n @param string where row name will be stored"]
    pub fn Cbc_getRowName(
        model: *mut Cbc_Model,
        iRow: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
        maxLength: usize,
    );
}
unsafe extern "C" {
    #[doc = " Queries column name\n\n @param model problem object\n @param iColumn column index\n @param name where name will be stored\n @param maxLength maximum length of name string"]
    pub fn Cbc_getColName(
        model: *mut Cbc_Model,
        iColumn: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
        maxLength: usize,
    );
}
unsafe extern "C" {
    #[doc = " @brief Number of non-zero entries in a row\n\n @param model problem object\n @param row row index\n @return number of non-zero entries in row"]
    pub fn Cbc_getRowNz(model: *mut Cbc_Model, row: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Indices of variables that appear on a row\n\n @param model problem object\n @param row row index\n @return vector with indexes of columns that appear on this row"]
    pub fn Cbc_getRowIndices(model: *mut Cbc_Model, row: ::std::os::raw::c_int) -> *const ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Coefficients of variables that appear on this row\n\n @param model problem object\n @param row row index\n @return coefficients of variables that appear on this row"]
    pub fn Cbc_getRowCoeffs(model: *mut Cbc_Model, row: ::std::os::raw::c_int) -> *const f64;
}
unsafe extern "C" {
    #[doc = " @brief Number of non-zero entries in a column\n\n @param model problem object\n @param col column index\n @return numbef of rows that this column appears"]
    pub fn Cbc_getColNz(model: *mut Cbc_Model, col: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Indices of rows that a column appears\n\n @param model problem object\n @param col column index\n @return indices of rows that this column appears"]
    pub fn Cbc_getColIndices(model: *mut Cbc_Model, col: ::std::os::raw::c_int) -> *const ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Coefficients that a column appear in rows\n\n @param model problem object\n @param col column index\n @return coefficients of this column in rows"]
    pub fn Cbc_getColCoeffs(model: *mut Cbc_Model, col: ::std::os::raw::c_int) -> *const f64;
}
unsafe extern "C" {
    #[doc = " @brief Right hand side of a row\n\n @param model problem object\n @param row row index\n @return row right hand side"]
    pub fn Cbc_getRowRHS(model: *mut Cbc_Model, row: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Sense a row\n @param model problem object\n @param row row index\n @return row sense: E for =, L for <=, G for >= and R for ranged row"]
    pub fn Cbc_getRowSense(model: *mut Cbc_Model, row: ::std::os::raw::c_int) -> ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Direction of optimization\n\n @param model problem object\n @return Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore)"]
    pub fn Cbc_getObjSense(model: *mut Cbc_Model) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Constraint lower bounds\n\n @param model problem object\n @return vector with lower bounds of constraints"]
    pub fn Cbc_getRowLower(model: *mut Cbc_Model) -> *const f64;
}
unsafe extern "C" {
    #[doc = " @brief Constraint upper bounds\n\n @param model problem object\n @return constraint upper bounds"]
    pub fn Cbc_getRowUpper(model: *mut Cbc_Model) -> *const f64;
}
unsafe extern "C" {
    #[doc = " @brief Objective vector\n\n @param model problem object\n @return vector with coefficients of variables in the objective function"]
    pub fn Cbc_getObjCoefficients(model: *mut Cbc_Model) -> *const f64;
}
unsafe extern "C" {
    #[doc = " @brief Variable lower bounds\n\n @param model problem object\n @return vector with lower bounds of variables"]
    pub fn Cbc_getColLower(model: *mut Cbc_Model) -> *const f64;
}
unsafe extern "C" {
    #[doc = " @brief Variable upper bounds\n\n @param model problem object\n @return vector with column upper bounds"]
    pub fn Cbc_getColUpper(model: *mut Cbc_Model) -> *const f64;
}
unsafe extern "C" {
    #[doc = " @brief Determine whether the ith variable is integer restricted\n\n @param model problem object\n @param i variable index\n @return 1 if variable is integer, 0 otherwise"]
    pub fn Cbc_isInteger(model: *mut Cbc_Model, i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Read an mps file from the given filename\n\n @param model problem object\n @param fileName file name"]
    pub fn Cbc_readMps(model: *mut Cbc_Model, filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Read an lp file from the given filename\n\n @param model problem object\n @param fileName file name"]
    pub fn Cbc_readLp(model: *mut Cbc_Model, filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Write an mps file from the given filename\n\n @param model problem object\n @param fileName file name"]
    pub fn Cbc_writeMps(model: *mut Cbc_Model, filename: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " @brief Write an lp file from the given filename\n\n @param model problem object\n @param fileName file name"]
    pub fn Cbc_writeLp(model: *mut Cbc_Model, filename: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Provide an initial feasible solution to accelerate branch-and-bound\nNote that feasibility of the solution is *not* verified."]
    pub fn Cbc_setInitialSolution(model: *mut Cbc_Model, sol: *const f64);
}
unsafe extern "C" {
    #[doc = " \"Column start\" vector of constraint matrix. Same format as Cbc_loadProblem()"]
    pub fn Cbc_getVectorStarts(model: *mut Cbc_Model) -> *const CoinBigIndex;
}
unsafe extern "C" {
    #[doc = " \"Row index\" vector of constraint matrix"]
    pub fn Cbc_getIndices(model: *mut Cbc_Model) -> *const ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Coefficient vector of constraint matrix"]
    pub fn Cbc_getElements(model: *mut Cbc_Model) -> *const f64;
}
unsafe extern "C" {
    #[doc = " Maximum lenght of a row or column name"]
    pub fn Cbc_maxNameLength(model: *mut Cbc_Model) -> usize;
}
unsafe extern "C" {
    #[doc = " Print the model"]
    pub fn Cbc_printModel(model: *mut Cbc_Model, argPrefix: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = "@name Solver parameters */\n/**@{*/\n/** Set parameter \"name\" to value \"value\". Note that this\n translates directly to using \"-name value\" as a\n command-line argument to Cbc."]
    pub fn Cbc_setParameter(
        model: *mut Cbc_Model,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " returns the allowable gap"]
    pub fn Cbc_getAllowableGap(model: *mut Cbc_Model) -> f64;
}
unsafe extern "C" {
    #[doc = " sets the allowable gap"]
    pub fn Cbc_setAllowableGap(model: *mut Cbc_Model, allowedGap: f64);
}
unsafe extern "C" {
    #[doc = " returns the allowable fraction gap"]
    pub fn Cbc_getAllowableFractionGap(model: *mut Cbc_Model) -> f64;
}
unsafe extern "C" {
    #[doc = " sets the allowable fraction gap"]
    pub fn Cbc_setAllowableFractionGap(model: *mut Cbc_Model, allowedFracionGap: f64);
}
unsafe extern "C" {
    #[doc = " returns the allowable percentage gap"]
    pub fn Cbc_getAllowablePercentageGap(model: *mut Cbc_Model) -> f64;
}
unsafe extern "C" {
    #[doc = " sets the allowable percentage gap"]
    pub fn Cbc_setAllowablePercentageGap(model: *mut Cbc_Model, allowedPercentageGap: f64);
}
unsafe extern "C" {
    #[doc = " returns the time limit for the search process"]
    pub fn Cbc_getMaximumSeconds(model: *mut Cbc_Model) -> f64;
}
unsafe extern "C" {
    #[doc = " sets the time limit for the search process"]
    pub fn Cbc_setMaximumSeconds(model: *mut Cbc_Model, maxSeconds: f64);
}
unsafe extern "C" {
    #[doc = " returns the maximum number of nodes that can be explored in the search tree"]
    pub fn Cbc_getMaximumNodes(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the maximum number of nodes that can be explored in the search tree"]
    pub fn Cbc_setMaximumNodes(model: *mut Cbc_Model, maxNodes: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " returns solution limit for the search process"]
    pub fn Cbc_getMaximumSolutions(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets a solution limit as a stopping criterion"]
    pub fn Cbc_setMaximumSolutions(model: *mut Cbc_Model, maxSolutions: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " returns the current log leven"]
    pub fn Cbc_getLogLevel(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " sets the log level"]
    pub fn Cbc_setLogLevel(model: *mut Cbc_Model, logLevel: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " returns the cutoff"]
    pub fn Cbc_getCutoff(model: *mut Cbc_Model) -> f64;
}
unsafe extern "C" {
    #[doc = " sets the cutoff"]
    pub fn Cbc_setCutoff(model: *mut Cbc_Model, cutoff: f64);
}
unsafe extern "C" {
    #[doc = "@}*/\n/**@name Message handling.  Call backs are handled by ONE function */\n/**@{*/\n/** Pass in Callback function.\nMessage numbers up to 1000000 are Clp, Coin ones have 1000000 added"]
    pub fn Cbc_registerCallBack(model: *mut Cbc_Model, userCallBack: cbc_callback);
}
unsafe extern "C" {
    #[doc = " Unset Callback function"]
    pub fn Cbc_clearCallBack(model: *mut Cbc_Model);
}
unsafe extern "C" {
    pub fn Cbc_addCutCallback(
        model: *mut Cbc_Model,
        cutcb: cbc_cut_callback,
        name: *const ::std::os::raw::c_char,
        appData: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = "@name Solving the model */\n/**@{"]
    pub fn Cbc_solve(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Best feasible solution vector\n\n @param model problem object\n @return vector with best solution found"]
    pub fn Cbc_getColSolution(model: *mut Cbc_Model) -> *const f64;
}
unsafe extern "C" {
    #[doc = " @brief Best known bound on the optimal objective value\n\n @param model problem object\n @return best possible cost (lower bound)"]
    pub fn Cbc_getBestPossibleObjValue(model: *mut Cbc_Model) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Best integer feasible solution\n\n Best integer feasible solution or NULL if no integer feas sol found\n\n @param model problem object\n @return vector with the best solution found or NULL if no feasible solution was found"]
    pub fn Cbc_bestSolution(model: *mut Cbc_Model) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " @brief number of integer feasible solution saved\n\n @param model problem object\n @return number of saved solutions"]
    pub fn Cbc_numberSavedSolutions(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Vector with the i-th saved solution\n\n @param model problem object\n @param whichSol index of the solution to be retrieved\n @return vector with integer feasible solution"]
    pub fn Cbc_savedSolution(model: *mut Cbc_Model, whichSol: ::std::os::raw::c_int) -> *const f64;
}
unsafe extern "C" {
    #[doc = " @brief Cost of the whichSol solution\n\n @param model problem object\n @param whichSol solution index\n @return solution cost"]
    pub fn Cbc_savedSolutionObj(model: *mut Cbc_Model, whichSol: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Queries vector of reduced costs\n\n @param model problem object\n @return reduced cost vector"]
    pub fn Cbc_getReducedCost(model: *mut Cbc_Model) -> *const f64;
}
unsafe extern "C" {
    #[doc = " If optimization was abandoned due to numerical difficulties\n\n @param model problem object\n @return 1 if numerical difficulties interrupted the optimization, 0 otherwise"]
    pub fn Cbc_isAbandoned(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief If the optimal solution was found\n\n @param model problem object\n @return 1 if optimal solution was found, 0 otherwise"]
    pub fn Cbc_isProvenOptimal(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief If infeasibility was proven\n\n If model is infeasible, please note that infeasibility can also be declared\n if cutoff is informed and no solution better than the cutoff exists.\n\n @param model problem object\n @return 1 if model is infeasible, 0 otherwise"]
    pub fn Cbc_isProvenInfeasible(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Is continuous model unbounded ?\n\n @param model problem object\n @return 1 if model is unbounded, 0 otherwise"]
    pub fn Cbc_isContinuousUnbounded(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Objective value of best feasible solution\n\n @param model problem object\n @return cost of the best solution found"]
    pub fn Cbc_getObjValue(model: *mut Cbc_Model) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Final optimization status\n\n Returns the optimization status. For more info check function\n isProvenOptimal, isProvenInfeasible, etc. Check also secondary status.\n Possible status are:\n\n -1 before branchAndBound\n 0 finished - check isProvenOptimal or isProvenInfeasible to see if solution found (or check value of best solution)\n 1 stopped - on maxnodes, maxsols, maxtime\n 2 execution abandoned due to numerical dificulties\n 5 user programmed interruption\n\n @param model problem object\n @return problem status"]
    pub fn Cbc_status(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Secondary status of problem\n\n Returns additional information regarding the optimization status\n\n -1 unset (status_ will also be -1)\n  0 search completed with solution\n  1 linear relaxation not feasible (or worse than cutoff)\n  2 stopped on gap\n  3 stopped on nodes\n  4 stopped on time\n  5 stopped on user event\n  6 stopped on solutions\n  7 linear relaxation unbounded\n  8 stopped on iteration limit\n\n  @model problem object\n  @return optimization status"]
    pub fn Cbc_secondaryStatus(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Sum of primal infeasibilities"]
    pub fn Cbc_sumPrimalInfeasibilities(model: *mut Cbc_Model) -> f64;
}
unsafe extern "C" {
    #[doc = " Number of primal infeasibilities"]
    pub fn Cbc_numberPrimalInfeasibilities(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Just check solution (for external use) - sets sum of\ninfeasibilities etc"]
    pub fn Cbc_checkSolution(model: *mut Cbc_Model);
}
unsafe extern "C" {
    #[doc = " Number of iterations"]
    pub fn Cbc_getIterationCount(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Node limit reached?"]
    pub fn Cbc_isNodeLimitReached(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Time limit reached?"]
    pub fn Cbc_isSecondsLimitReached(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Solution limit reached?"]
    pub fn Cbc_isSolutionLimitReached(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Are there numerical difficulties (for initialSolve) ?"]
    pub fn Cbc_isInitialSolveAbandoned(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Is optimality proven (for initialSolve) ?"]
    pub fn Cbc_isInitialSolveProvenOptimal(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Is primal infeasiblity proven (for initialSolve) ?"]
    pub fn Cbc_isInitialSolveProvenPrimalInfeasible(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \"row\" solution\n  This is the vector A*x, where A is the constraint matrix\n  and x is the current solution."]
    pub fn Cbc_getRowActivity(model: *mut Cbc_Model) -> *const f64;
}
unsafe extern "C" {
    #[doc = " Number of nodes explored in B&B tree"]
    pub fn Cbc_getNodeCount(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Print the solution"]
    pub fn Cbc_printSolution(model: *mut Cbc_Model);
}
unsafe extern "C" {
    #[doc = " @brief Returns number of cols in OsiSolverInterface object"]
    pub fn Osi_getNumCols(osi: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns column name in OsiSolverInterface object"]
    pub fn Osi_getColName(
        osi: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
        maxLen: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Returns column lower bounds in OsiSolverInterface object"]
    pub fn Osi_getColLower(osi: *mut ::std::os::raw::c_void) -> *const f64;
}
unsafe extern "C" {
    #[doc = " @brief Returns column upper bounds in OsiSolverInterface object"]
    pub fn Osi_getColUpper(osi: *mut ::std::os::raw::c_void) -> *const f64;
}
unsafe extern "C" {
    #[doc = " @brief Returns integrality information for columns in OsiSolverInterface object"]
    pub fn Osi_isInteger(osi: *mut ::std::os::raw::c_void, col: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Returns number of rows in OsiSolverInterface object"]
    pub fn Osi_getNumRows(osi: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn Osi_getRowNz(osi: *mut ::std::os::raw::c_void, row: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Indices of variables that appear on a row"]
    pub fn Osi_getRowIndices(
        osi: *mut ::std::os::raw::c_void,
        row: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Coefficients of variables that appear on this row\n\n @param model problem object\n @param row row index\n @return coefficients of variables that appear on this row"]
    pub fn Osi_getRowCoeffs(osi: *mut ::std::os::raw::c_void, row: ::std::os::raw::c_int) -> *const f64;
}
unsafe extern "C" {
    #[doc = " @brief Right hand side of a row\n\n @param model problem object\n @param row row index\n @return row right hand side"]
    pub fn Osi_getRowRHS(osi: *mut ::std::os::raw::c_void, row: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    #[doc = " @brief Sense a row\n @param model problem object\n @param row row index\n @return row sense: E for =, L for <=, G for >= and R for ranged row"]
    pub fn Osi_getRowSense(osi: *mut ::std::os::raw::c_void, row: ::std::os::raw::c_int) -> ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Returns solution vector in OsiSolverInterface object"]
    pub fn Osi_getColSolution(osi: *mut ::std::os::raw::c_void) -> *const f64;
}
unsafe extern "C" {
    #[doc = " adds a row cut (used in callback)"]
    pub fn OsiCuts_addRowCut(
        osiCuts: *mut ::std::os::raw::c_void,
        nz: ::std::os::raw::c_int,
        idx: *const ::std::os::raw::c_int,
        coef: *const f64,
        sense: ::std::os::raw::c_char,
        rhs: f64,
    );
}
