/* automatically generated by rust-bindgen 0.71.1 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub type Clp_Simplex = ::std::os::raw::c_void;
pub type clp_callback = ::std::option::Option<
    unsafe extern "C" fn(
        model: *mut Clp_Simplex,
        msgno: ::std::os::raw::c_int,
        ndouble: ::std::os::raw::c_int,
        dvec: *const f64,
        nint: ::std::os::raw::c_int,
        ivec: *const ::std::os::raw::c_int,
        nchar: ::std::os::raw::c_int,
        cvec: *mut *mut ::std::os::raw::c_char,
    ),
>;
pub type Sbb_Model = ::std::os::raw::c_void;
pub type Cbc_Model = ::std::os::raw::c_void;
#[doc = " typedef for user call back.\nThe cvec are constructed so don't need to be const"]
pub type sbb_callback = ::std::option::Option<
    unsafe extern "C" fn(
        model: *mut Sbb_Model,
        msgno: ::std::os::raw::c_int,
        ndouble: ::std::os::raw::c_int,
        dvec: *const f64,
        nint: ::std::os::raw::c_int,
        ivec: *const ::std::os::raw::c_int,
        nchar: ::std::os::raw::c_int,
        cvec: *mut *mut ::std::os::raw::c_char,
    ),
>;
pub type cbc_callback = ::std::option::Option<
    unsafe extern "C" fn(
        model: *mut Cbc_Model,
        msgno: ::std::os::raw::c_int,
        ndouble: ::std::os::raw::c_int,
        dvec: *const f64,
        nint: ::std::os::raw::c_int,
        ivec: *const ::std::os::raw::c_int,
        nchar: ::std::os::raw::c_int,
        cvec: *mut *mut ::std::os::raw::c_char,
    ),
>;
#[doc = " typedef for cbc cut callback osiSolver needs to be an OsiSolverInterface object,\n osiCuts is an OsiCuts object and appdata is a pointer that will be passed to the cut\n generation, you can use it to point to a data structure with information about the original problem,\n for instance"]
pub type cbc_cut_callback = ::std::option::Option<
    unsafe extern "C" fn(
        osiSolver: *mut ::std::os::raw::c_void,
        osiCuts: *mut ::std::os::raw::c_void,
        appdata: *mut ::std::os::raw::c_void,
    ),
>;
pub type CoinBigIndex = ::std::os::raw::c_int;
pub type Clp_Solve = ::std::os::raw::c_void;
unsafe extern "C" {
    #[doc = " Clp library version number as string."]
    pub fn Clp_Version() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Major number of Clp library version."]
    pub fn Clp_VersionMajor() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Minor number of Clp library version."]
    pub fn Clp_VersionMinor() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Release number of Clp library version."]
    pub fn Clp_VersionRelease() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Default constructor"]
    pub fn Clp_newModel() -> *mut Clp_Simplex;
}
unsafe extern "C" {
    #[doc = " Destructor"]
    pub fn Clp_deleteModel(model: *mut Clp_Simplex);
}
unsafe extern "C" {
    #[doc = " Default constructor"]
    pub fn ClpSolve_new() -> *mut Clp_Solve;
}
unsafe extern "C" {
    #[doc = " Destructor"]
    pub fn ClpSolve_delete(solve: *mut Clp_Solve);
}
unsafe extern "C" {
    #[doc = " Loads a problem (the constraints on the\nrows are given by lower and upper bounds). If a pointer is NULL then the\nfollowing values are the default:\n<ul>\n<li> <code>colub</code>: all columns have upper bound infinity\n<li> <code>collb</code>: all columns have lower bound 0\n<li> <code>rowub</code>: all rows have upper bound infinity\n<li> <code>rowlb</code>: all rows have lower bound -infinity\n<li> <code>obj</code>: all variables have 0 objective coefficient\n</ul>\n/\n/** Just like the other loadProblem() method except that the matrix is\ngiven in a standard column major ordered format (without gaps)."]
    pub fn Clp_loadProblem(
        model: *mut Clp_Simplex,
        numcols: ::std::os::raw::c_int,
        numrows: ::std::os::raw::c_int,
        start: *const CoinBigIndex,
        index: *const ::std::os::raw::c_int,
        value: *const f64,
        collb: *const f64,
        colub: *const f64,
        obj: *const f64,
        rowlb: *const f64,
        rowub: *const f64,
    );
}
unsafe extern "C" {
    pub fn Clp_loadQuadraticObjective(
        model: *mut Clp_Simplex,
        numberColumns: ::std::os::raw::c_int,
        start: *const CoinBigIndex,
        column: *const ::std::os::raw::c_int,
        element: *const f64,
    );
}
unsafe extern "C" {
    #[doc = " Read an mps file from the given filename"]
    pub fn Clp_readMps(
        model: *mut Clp_Simplex,
        filename: *const ::std::os::raw::c_char,
        keepNames: ::std::os::raw::c_int,
        ignoreErrors: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Write an mps file to the given filename */\n/** Format type is 0 = normal, 1 = extra or 2 = hex.\nNumber across is 1 or 2.\nUse objSense = -1D to flip the objective function around."]
    pub fn Clp_writeMps(
        model: *mut Clp_Simplex,
        filename: *const ::std::os::raw::c_char,
        formatType: ::std::os::raw::c_int,
        numberAcross: ::std::os::raw::c_int,
        objSense: f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Copy in integer informations"]
    pub fn Clp_copyInIntegerInformation(model: *mut Clp_Simplex, information: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Drop integer informations"]
    pub fn Clp_deleteIntegerInformation(model: *mut Clp_Simplex);
}
unsafe extern "C" {
    #[doc = " Resizes rim part of model"]
    pub fn Clp_resize(
        model: *mut Clp_Simplex,
        newNumberRows: ::std::os::raw::c_int,
        newNumberColumns: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Deletes rows"]
    pub fn Clp_deleteRows(model: *mut Clp_Simplex, number: ::std::os::raw::c_int, which: *const ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Add rows"]
    pub fn Clp_addRows(
        model: *mut Clp_Simplex,
        number: ::std::os::raw::c_int,
        rowLower: *const f64,
        rowUpper: *const f64,
        rowStarts: *const CoinBigIndex,
        columns: *const ::std::os::raw::c_int,
        elements: *const f64,
    );
}
unsafe extern "C" {
    #[doc = " Deletes columns"]
    pub fn Clp_deleteColumns(
        model: *mut Clp_Simplex,
        number: ::std::os::raw::c_int,
        which: *const ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Add columns"]
    pub fn Clp_addColumns(
        model: *mut Clp_Simplex,
        number: ::std::os::raw::c_int,
        columnLower: *const f64,
        columnUpper: *const f64,
        objective: *const f64,
        columnStarts: *const CoinBigIndex,
        rows: *const ::std::os::raw::c_int,
        elements: *const f64,
    );
}
unsafe extern "C" {
    #[doc = " Change row lower bounds"]
    pub fn Clp_chgRowLower(model: *mut Clp_Simplex, rowLower: *const f64);
}
unsafe extern "C" {
    #[doc = " Change row upper bounds"]
    pub fn Clp_chgRowUpper(model: *mut Clp_Simplex, rowUpper: *const f64);
}
unsafe extern "C" {
    #[doc = " Change column lower bounds"]
    pub fn Clp_chgColumnLower(model: *mut Clp_Simplex, columnLower: *const f64);
}
unsafe extern "C" {
    #[doc = " Change column upper bounds"]
    pub fn Clp_chgColumnUpper(model: *mut Clp_Simplex, columnUpper: *const f64);
}
unsafe extern "C" {
    #[doc = " Change objective coefficients"]
    pub fn Clp_chgObjCoefficients(model: *mut Clp_Simplex, objIn: *const f64);
}
unsafe extern "C" {
    pub fn Clp_modifyCoefficient(
        model: *mut Clp_Simplex,
        row: ::std::os::raw::c_int,
        column: ::std::os::raw::c_int,
        newElement: f64,
        keepZero: bool,
    );
}
unsafe extern "C" {
    #[doc = " Drops names - makes lengthnames 0 and names empty"]
    pub fn Clp_dropNames(model: *mut Clp_Simplex);
}
unsafe extern "C" {
    #[doc = " Copies in names"]
    pub fn Clp_copyNames(
        model: *mut Clp_Simplex,
        rowNames: *const *const ::std::os::raw::c_char,
        columnNames: *const *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Number of rows"]
    pub fn Clp_numberRows(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Number of columns"]
    pub fn Clp_numberColumns(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Primal tolerance to use"]
    pub fn Clp_primalTolerance(model: *mut Clp_Simplex) -> f64;
}
unsafe extern "C" {
    pub fn Clp_setPrimalTolerance(model: *mut Clp_Simplex, value: f64);
}
unsafe extern "C" {
    #[doc = " Dual tolerance to use"]
    pub fn Clp_dualTolerance(model: *mut Clp_Simplex) -> f64;
}
unsafe extern "C" {
    pub fn Clp_setDualTolerance(model: *mut Clp_Simplex, value: f64);
}
unsafe extern "C" {
    #[doc = " Dual objective limit"]
    pub fn Clp_dualObjectiveLimit(model: *mut Clp_Simplex) -> f64;
}
unsafe extern "C" {
    pub fn Clp_setDualObjectiveLimit(model: *mut Clp_Simplex, value: f64);
}
unsafe extern "C" {
    #[doc = " Objective offset"]
    pub fn Clp_objectiveOffset(model: *mut Clp_Simplex) -> f64;
}
unsafe extern "C" {
    pub fn Clp_setObjectiveOffset(model: *mut Clp_Simplex, value: f64);
}
unsafe extern "C" {
    #[doc = " Fills in array with problem name"]
    pub fn Clp_problemName(
        model: *mut Clp_Simplex,
        maxNumberCharacters: ::std::os::raw::c_int,
        array: *mut ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn Clp_setProblemName(
        model: *mut Clp_Simplex,
        maxNumberCharacters: ::std::os::raw::c_int,
        array: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Number of iterations"]
    pub fn Clp_numberIterations(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn Clp_setNumberIterations(model: *mut Clp_Simplex, numberIterations: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Maximum number of iterations"]
    pub fn maximumIterations(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn Clp_setMaximumIterations(model: *mut Clp_Simplex, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Maximum time in seconds (from when set called)"]
    pub fn Clp_maximumSeconds(model: *mut Clp_Simplex) -> f64;
}
unsafe extern "C" {
    pub fn Clp_setMaximumSeconds(model: *mut Clp_Simplex, value: f64);
}
unsafe extern "C" {
    #[doc = " Returns true if hit maximum iterations (or time)"]
    pub fn Clp_hitMaximumIterations(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Status of problem:\n0 - optimal\n1 - primal infeasible\n2 - dual infeasible\n3 - stopped on iterations etc\n4 - stopped due to errors"]
    pub fn Clp_status(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set problem status"]
    pub fn Clp_setProblemStatus(model: *mut Clp_Simplex, problemStatus: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Secondary status of problem - may get extended\n0 - none\n1 - primal infeasible because dual limit reached\n2 - scaled problem optimal - unscaled has primal infeasibilities\n3 - scaled problem optimal - unscaled has dual infeasibilities\n4 - scaled problem optimal - unscaled has both dual and primal infeasibilities"]
    pub fn Clp_secondaryStatus(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn Clp_setSecondaryStatus(model: *mut Clp_Simplex, status: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore"]
    pub fn Clp_optimizationDirection(model: *mut Clp_Simplex) -> f64;
}
unsafe extern "C" {
    pub fn Clp_setOptimizationDirection(model: *mut Clp_Simplex, value: f64);
}
unsafe extern "C" {
    #[doc = " Primal row solution"]
    pub fn Clp_primalRowSolution(model: *mut Clp_Simplex) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " Primal column solution"]
    pub fn Clp_primalColumnSolution(model: *mut Clp_Simplex) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " Dual row solution"]
    pub fn Clp_dualRowSolution(model: *mut Clp_Simplex) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " Reduced costs"]
    pub fn Clp_dualColumnSolution(model: *mut Clp_Simplex) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " Row lower"]
    pub fn Clp_rowLower(model: *mut Clp_Simplex) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " Row upper"]
    pub fn Clp_rowUpper(model: *mut Clp_Simplex) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " Objective"]
    pub fn Clp_objective(model: *mut Clp_Simplex) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " Column Lower"]
    pub fn Clp_columnLower(model: *mut Clp_Simplex) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " Column Upper"]
    pub fn Clp_columnUpper(model: *mut Clp_Simplex) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " Number of elements in matrix"]
    pub fn Clp_getNumElements(model: *mut Clp_Simplex) -> CoinBigIndex;
}
unsafe extern "C" {
    pub fn Clp_getVectorStarts(model: *mut Clp_Simplex) -> *const CoinBigIndex;
}
unsafe extern "C" {
    pub fn Clp_getIndices(model: *mut Clp_Simplex) -> *const ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn Clp_getVectorLengths(model: *mut Clp_Simplex) -> *const ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn Clp_getElements(model: *mut Clp_Simplex) -> *const f64;
}
unsafe extern "C" {
    #[doc = " Objective value"]
    pub fn Clp_objectiveValue(model: *mut Clp_Simplex) -> f64;
}
unsafe extern "C" {
    #[doc = " Integer information"]
    pub fn Clp_integerInformation(model: *mut Clp_Simplex) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Gives Infeasibility ray.\n\n Use Clp_freeRay to free the returned array.\n\n @return infeasibility ray, or NULL returned if none/wrong."]
    pub fn Clp_infeasibilityRay(model: *mut Clp_Simplex) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " Gives ray in which the problem is unbounded.\n\n Use Clp_freeRay to free the returned array.\n\n @return unbounded ray, or NULL returned if none/wrong."]
    pub fn Clp_unboundedRay(model: *mut Clp_Simplex) -> *mut f64;
}
unsafe extern "C" {
    #[doc = " Frees a infeasibility or unbounded ray."]
    pub fn Clp_freeRay(model: *mut Clp_Simplex, ray: *mut f64);
}
unsafe extern "C" {
    #[doc = " See if status array exists (partly for OsiClp)"]
    pub fn Clp_statusExists(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return address of status array (char[numberRows+numberColumns])"]
    pub fn Clp_statusArray(model: *mut Clp_Simplex) -> *mut ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    #[doc = " Copy in status vector"]
    pub fn Clp_copyinStatus(model: *mut Clp_Simplex, statusArray: *const ::std::os::raw::c_uchar);
}
unsafe extern "C" {
    pub fn Clp_getColumnStatus(model: *mut Clp_Simplex, sequence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn Clp_getRowStatus(model: *mut Clp_Simplex, sequence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn Clp_setColumnStatus(model: *mut Clp_Simplex, sequence: ::std::os::raw::c_int, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn Clp_setRowStatus(model: *mut Clp_Simplex, sequence: ::std::os::raw::c_int, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " User pointer for whatever reason"]
    pub fn Clp_setUserPointer(model: *mut Clp_Simplex, pointer: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn Clp_getUserPointer(model: *mut Clp_Simplex) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Pass in Callback function.\nMessage numbers up to 1000000 are Clp, Coin ones have 1000000 added"]
    pub fn Clp_registerCallBack(model: *mut Clp_Simplex, userCallBack: clp_callback);
}
unsafe extern "C" {
    #[doc = " Unset Callback function"]
    pub fn Clp_clearCallBack(model: *mut Clp_Simplex);
}
unsafe extern "C" {
    #[doc = " Amount of print out:\n0 - none\n1 - just final\n2 - just factorizations\n3 - as 2 plus a bit more\n4 - verbose\nabove that 8,16,32 etc just for selective debug"]
    pub fn Clp_setLogLevel(model: *mut Clp_Simplex, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn Clp_logLevel(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " length of names (0 means no names0"]
    pub fn Clp_lengthNames(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Fill in array (at least lengthNames+1 long) with a row name"]
    pub fn Clp_rowName(model: *mut Clp_Simplex, iRow: ::std::os::raw::c_int, name: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Fill in array (at least lengthNames+1 long) with a column name"]
    pub fn Clp_columnName(model: *mut Clp_Simplex, iColumn: ::std::os::raw::c_int, name: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Set row name - Nice if they are short - 8 chars or less I think"]
    pub fn Clp_setRowName(model: *mut Clp_Simplex, iRow: ::std::os::raw::c_int, name: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Set column name - Nice if they are short - 8 chars or less I think"]
    pub fn Clp_setColumnName(
        model: *mut Clp_Simplex,
        iColumn: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " General solve algorithm which can do presolve.\nSee  ClpSolve.hpp for options"]
    pub fn Clp_initialSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Pass solve options. (Exception to direct analogue rule)"]
    pub fn Clp_initialSolveWithOptions(model: *mut Clp_Simplex, arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Dual initial solve"]
    pub fn Clp_initialDualSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Primal initial solve"]
    pub fn Clp_initialPrimalSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Barrier initial solve"]
    pub fn Clp_initialBarrierSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Barrier initial solve, no crossover"]
    pub fn Clp_initialBarrierNoCrossSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Dual algorithm - see ClpSimplexDual.hpp for method"]
    pub fn Clp_dual(model: *mut Clp_Simplex, ifValuesPass: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Primal algorithm - see ClpSimplexPrimal.hpp for method"]
    pub fn Clp_primal(model: *mut Clp_Simplex, ifValuesPass: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Solve the problem with the idiot code"]
    pub fn Clp_idiot(model: *mut Clp_Simplex, tryhard: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Sets or unsets scaling, 0 -off, 1 equilibrium, 2 geometric, 3, auto, 4 dynamic(later)"]
    pub fn Clp_scaling(model: *mut Clp_Simplex, mode: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Gets scalingFlag"]
    pub fn Clp_scalingFlag(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Crash - at present just aimed at dual, returns\n-2 if dual preferred and crash basis created\n-1 if dual preferred and all slack basis preferred\n0 if basis going in was not all slack\n1 if primal preferred and all slack basis preferred\n2 if primal preferred and crash basis created.\n\nif gap between bounds <=\"gap\" variables can be flipped\n\nIf \"pivot\" is\n0 No pivoting (so will just be choice of algorithm)\n1 Simple pivoting e.g. gub\n2 Mini iterations"]
    pub fn Clp_crash(model: *mut Clp_Simplex, gap: f64, pivot: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " If problem is primal feasible"]
    pub fn Clp_primalFeasible(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " If problem is dual feasible"]
    pub fn Clp_dualFeasible(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Dual bound"]
    pub fn Clp_dualBound(model: *mut Clp_Simplex) -> f64;
}
unsafe extern "C" {
    pub fn Clp_setDualBound(model: *mut Clp_Simplex, value: f64);
}
unsafe extern "C" {
    #[doc = " Infeasibility cost"]
    pub fn Clp_infeasibilityCost(model: *mut Clp_Simplex) -> f64;
}
unsafe extern "C" {
    pub fn Clp_setInfeasibilityCost(model: *mut Clp_Simplex, value: f64);
}
unsafe extern "C" {
    #[doc = " Perturbation:\n50  - switch on perturbation\n100 - auto perturb if takes too long (1.0e-6 largest nonzero)\n101 - we are perturbed\n102 - don't try perturbing again\ndefault is 100\nothers are for playing"]
    pub fn Clp_perturbation(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn Clp_setPerturbation(model: *mut Clp_Simplex, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Current (or last) algorithm"]
    pub fn Clp_algorithm(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set algorithm"]
    pub fn Clp_setAlgorithm(model: *mut Clp_Simplex, value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Sum of dual infeasibilities"]
    pub fn Clp_sumDualInfeasibilities(model: *mut Clp_Simplex) -> f64;
}
unsafe extern "C" {
    #[doc = " Number of dual infeasibilities"]
    pub fn Clp_numberDualInfeasibilities(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Sum of primal infeasibilities"]
    pub fn Clp_sumPrimalInfeasibilities(model: *mut Clp_Simplex) -> f64;
}
unsafe extern "C" {
    #[doc = " Number of primal infeasibilities"]
    pub fn Clp_numberPrimalInfeasibilities(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Save model to file, returns 0 if success.  This is designed for\nuse outside algorithms so does not save iterating arrays etc.\nIt does not save any messaging information.\nDoes not save scaling values.\nIt does not know about all types of virtual functions."]
    pub fn Clp_saveModel(model: *mut Clp_Simplex, fileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Restore model from file, returns 0 if success,\ndeletes current model"]
    pub fn Clp_restoreModel(model: *mut Clp_Simplex, fileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Just check solution (for external use) - sets sum of\ninfeasibilities etc"]
    pub fn Clp_checkSolution(model: *mut Clp_Simplex);
}
unsafe extern "C" {
    #[doc = " Number of rows"]
    pub fn Clp_getNumRows(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Number of columns"]
    pub fn Clp_getNumCols(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Number of iterations"]
    pub fn Clp_getIterationCount(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Are there a numerical difficulties?"]
    pub fn Clp_isAbandoned(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Is optimality proven?"]
    pub fn Clp_isProvenOptimal(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Is primal infeasiblity proven?"]
    pub fn Clp_isProvenPrimalInfeasible(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Is dual infeasiblity proven?"]
    pub fn Clp_isProvenDualInfeasible(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Is the given primal objective limit reached?"]
    pub fn Clp_isPrimalObjectiveLimitReached(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Is the given dual objective limit reached?"]
    pub fn Clp_isDualObjectiveLimitReached(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Iteration limit reached?"]
    pub fn Clp_isIterationLimitReached(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore"]
    pub fn Clp_getObjSense(model: *mut Clp_Simplex) -> f64;
}
unsafe extern "C" {
    #[doc = " Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore"]
    pub fn Clp_setObjSense(model: *mut Clp_Simplex, objsen: f64);
}
unsafe extern "C" {
    #[doc = " Primal row solution"]
    pub fn Clp_getRowActivity(model: *mut Clp_Simplex) -> *const f64;
}
unsafe extern "C" {
    #[doc = " Primal column solution"]
    pub fn Clp_getColSolution(model: *mut Clp_Simplex) -> *const f64;
}
unsafe extern "C" {
    pub fn Clp_setColSolution(model: *mut Clp_Simplex, input: *const f64);
}
unsafe extern "C" {
    #[doc = " Dual row solution"]
    pub fn Clp_getRowPrice(model: *mut Clp_Simplex) -> *const f64;
}
unsafe extern "C" {
    #[doc = " Reduced costs"]
    pub fn Clp_getReducedCost(model: *mut Clp_Simplex) -> *const f64;
}
unsafe extern "C" {
    #[doc = " Row lower"]
    pub fn Clp_getRowLower(model: *mut Clp_Simplex) -> *const f64;
}
unsafe extern "C" {
    #[doc = " Row upper"]
    pub fn Clp_getRowUpper(model: *mut Clp_Simplex) -> *const f64;
}
unsafe extern "C" {
    #[doc = " Objective"]
    pub fn Clp_getObjCoefficients(model: *mut Clp_Simplex) -> *const f64;
}
unsafe extern "C" {
    #[doc = " Column Lower"]
    pub fn Clp_getColLower(model: *mut Clp_Simplex) -> *const f64;
}
unsafe extern "C" {
    #[doc = " Column Upper"]
    pub fn Clp_getColUpper(model: *mut Clp_Simplex) -> *const f64;
}
unsafe extern "C" {
    #[doc = " Objective value"]
    pub fn Clp_getObjValue(model: *mut Clp_Simplex) -> f64;
}
unsafe extern "C" {
    #[doc = " Print model for debugging purposes"]
    pub fn Clp_printModel(model: *mut Clp_Simplex, prefix: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn Clp_getSmallElementValue(model: *mut Clp_Simplex) -> f64;
}
unsafe extern "C" {
    pub fn Clp_setSmallElementValue(model: *mut Clp_Simplex, value: f64);
}
unsafe extern "C" {
    pub fn ClpSolve_setSpecialOption(
        arg1: *mut Clp_Solve,
        which: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
        extraInfo: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ClpSolve_getSpecialOption(arg1: *mut Clp_Solve, which: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " method: (see ClpSolve::SolveType)\n0 - dual simplex\n1 - primal simplex\n2 - primal or sprint\n3 - barrier\n4 - barrier no crossover\n5 - automatic\n6 - not implemented\n-- pass extraInfo == -1 for default behavior"]
    pub fn ClpSolve_setSolveType(arg1: *mut Clp_Solve, method: ::std::os::raw::c_int, extraInfo: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ClpSolve_getSolveType(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " amount: (see ClpSolve::PresolveType)\n0 - presolve on\n1 - presolve off\n2 - presolve number\n3 - presolve number cost\n-- pass extraInfo == -1 for default behavior"]
    pub fn ClpSolve_setPresolveType(
        arg1: *mut Clp_Solve,
        amount: ::std::os::raw::c_int,
        extraInfo: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn ClpSolve_getPresolveType(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ClpSolve_getPresolvePasses(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ClpSolve_getExtraInfo(arg1: *mut Clp_Solve, which: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ClpSolve_setInfeasibleReturn(arg1: *mut Clp_Solve, trueFalse: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ClpSolve_infeasibleReturn(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ClpSolve_doDual(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ClpSolve_setDoDual(arg1: *mut Clp_Solve, doDual: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ClpSolve_doSingleton(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ClpSolve_setDoSingleton(arg1: *mut Clp_Solve, doSingleton: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ClpSolve_doDoubleton(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ClpSolve_setDoDoubleton(arg1: *mut Clp_Solve, doDoubleton: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ClpSolve_doTripleton(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ClpSolve_setDoTripleton(arg1: *mut Clp_Solve, doTripleton: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ClpSolve_doTighten(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ClpSolve_setDoTighten(arg1: *mut Clp_Solve, doTighten: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ClpSolve_doForcing(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ClpSolve_setDoForcing(arg1: *mut Clp_Solve, doForcing: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ClpSolve_doImpliedFree(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ClpSolve_setDoImpliedFree(arg1: *mut Clp_Solve, doImpliedFree: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ClpSolve_doDupcol(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ClpSolve_setDoDupcol(arg1: *mut Clp_Solve, doDupcol: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ClpSolve_doDuprow(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ClpSolve_setDoDuprow(arg1: *mut Clp_Solve, doDuprow: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ClpSolve_doSingletonColumn(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ClpSolve_setDoSingletonColumn(arg1: *mut Clp_Solve, doSingleton: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ClpSolve_presolveActions(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ClpSolve_setPresolveActions(arg1: *mut Clp_Solve, action: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ClpSolve_substitution(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ClpSolve_setSubstitution(arg1: *mut Clp_Solve, value: ::std::os::raw::c_int);
}
