/* automatically generated by rust-bindgen 0.69.4 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub type Clp_Simplex = ::std::os::raw::c_void;
pub type clp_callback = ::std::option::Option<
    unsafe extern "C" fn(
        model: *mut Clp_Simplex,
        msgno: ::std::os::raw::c_int,
        ndouble: ::std::os::raw::c_int,
        dvec: *const f64,
        nint: ::std::os::raw::c_int,
        ivec: *const ::std::os::raw::c_int,
        nchar: ::std::os::raw::c_int,
        cvec: *mut *mut ::std::os::raw::c_char,
    ),
>;
pub type Sbb_Model = ::std::os::raw::c_void;
pub type Cbc_Model = ::std::os::raw::c_void;
#[doc = " typedef for user call back.\nThe cvec are constructed so don't need to be const"]
pub type sbb_callback = ::std::option::Option<
    unsafe extern "C" fn(
        model: *mut Sbb_Model,
        msgno: ::std::os::raw::c_int,
        ndouble: ::std::os::raw::c_int,
        dvec: *const f64,
        nint: ::std::os::raw::c_int,
        ivec: *const ::std::os::raw::c_int,
        nchar: ::std::os::raw::c_int,
        cvec: *mut *mut ::std::os::raw::c_char,
    ),
>;
pub type cbc_callback = ::std::option::Option<
    unsafe extern "C" fn(
        model: *mut Cbc_Model,
        msgno: ::std::os::raw::c_int,
        ndouble: ::std::os::raw::c_int,
        dvec: *const f64,
        nint: ::std::os::raw::c_int,
        ivec: *const ::std::os::raw::c_int,
        nchar: ::std::os::raw::c_int,
        cvec: *mut *mut ::std::os::raw::c_char,
    ),
>;
#[doc = " typedef for cbc cut callback osiSolver needs to be an OsiSolverInterface object,\n osiCuts is an OsiCuts object and appdata is a pointer that will be passed to the cut\n generation, you can use it to point to a data structure with information about the original problem,\n for instance"]
pub type cbc_cut_callback = ::std::option::Option<
    unsafe extern "C" fn(
        osiSolver: *mut ::std::os::raw::c_void,
        osiCuts: *mut ::std::os::raw::c_void,
        appdata: *mut ::std::os::raw::c_void,
    ),
>;
pub type CoinBigIndex = ::std::os::raw::c_int;
pub type Clp_Solve = ::std::os::raw::c_void;
extern "C" {
    #[doc = " Clp library version number as string."]
    pub fn Clp_Version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Major number of Clp library version."]
    pub fn Clp_VersionMajor() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Minor number of Clp library version."]
    pub fn Clp_VersionMinor() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release number of Clp library version."]
    pub fn Clp_VersionRelease() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Default constructor"]
    pub fn Clp_newModel() -> *mut Clp_Simplex;
}
extern "C" {
    #[doc = " Destructor"]
    pub fn Clp_deleteModel(model: *mut Clp_Simplex);
}
extern "C" {
    #[doc = " Default constructor"]
    pub fn ClpSolve_new() -> *mut Clp_Solve;
}
extern "C" {
    #[doc = " Destructor"]
    pub fn ClpSolve_delete(solve: *mut Clp_Solve);
}
extern "C" {
    #[doc = " Loads a problem (the constraints on the\nrows are given by lower and upper bounds). If a pointer is NULL then the\nfollowing values are the default:\n<ul>\n<li> <code>colub</code>: all columns have upper bound infinity\n<li> <code>collb</code>: all columns have lower bound 0\n<li> <code>rowub</code>: all rows have upper bound infinity\n<li> <code>rowlb</code>: all rows have lower bound -infinity\n<li> <code>obj</code>: all variables have 0 objective coefficient\n</ul>\n/\n/** Just like the other loadProblem() method except that the matrix is\ngiven in a standard column major ordered format (without gaps)."]
    pub fn Clp_loadProblem(
        model: *mut Clp_Simplex,
        numcols: ::std::os::raw::c_int,
        numrows: ::std::os::raw::c_int,
        start: *const CoinBigIndex,
        index: *const ::std::os::raw::c_int,
        value: *const f64,
        collb: *const f64,
        colub: *const f64,
        obj: *const f64,
        rowlb: *const f64,
        rowub: *const f64,
    );
}
extern "C" {
    pub fn Clp_loadQuadraticObjective(
        model: *mut Clp_Simplex,
        numberColumns: ::std::os::raw::c_int,
        start: *const CoinBigIndex,
        column: *const ::std::os::raw::c_int,
        element: *const f64,
    );
}
extern "C" {
    #[doc = " Read an mps file from the given filename"]
    pub fn Clp_readMps(
        model: *mut Clp_Simplex,
        filename: *const ::std::os::raw::c_char,
        keepNames: ::std::os::raw::c_int,
        ignoreErrors: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write an mps file to the given filename */\n/** Format type is 0 = normal, 1 = extra or 2 = hex.\nNumber across is 1 or 2.\nUse objSense = -1D to flip the objective function around."]
    pub fn Clp_writeMps(
        model: *mut Clp_Simplex,
        filename: *const ::std::os::raw::c_char,
        formatType: ::std::os::raw::c_int,
        numberAcross: ::std::os::raw::c_int,
        objSense: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy in integer informations"]
    pub fn Clp_copyInIntegerInformation(model: *mut Clp_Simplex, information: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Drop integer informations"]
    pub fn Clp_deleteIntegerInformation(model: *mut Clp_Simplex);
}
extern "C" {
    #[doc = " Resizes rim part of model"]
    pub fn Clp_resize(
        model: *mut Clp_Simplex,
        newNumberRows: ::std::os::raw::c_int,
        newNumberColumns: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Deletes rows"]
    pub fn Clp_deleteRows(model: *mut Clp_Simplex, number: ::std::os::raw::c_int, which: *const ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Add rows"]
    pub fn Clp_addRows(
        model: *mut Clp_Simplex,
        number: ::std::os::raw::c_int,
        rowLower: *const f64,
        rowUpper: *const f64,
        rowStarts: *const CoinBigIndex,
        columns: *const ::std::os::raw::c_int,
        elements: *const f64,
    );
}
extern "C" {
    #[doc = " Deletes columns"]
    pub fn Clp_deleteColumns(
        model: *mut Clp_Simplex,
        number: ::std::os::raw::c_int,
        which: *const ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Add columns"]
    pub fn Clp_addColumns(
        model: *mut Clp_Simplex,
        number: ::std::os::raw::c_int,
        columnLower: *const f64,
        columnUpper: *const f64,
        objective: *const f64,
        columnStarts: *const CoinBigIndex,
        rows: *const ::std::os::raw::c_int,
        elements: *const f64,
    );
}
extern "C" {
    #[doc = " Change row lower bounds"]
    pub fn Clp_chgRowLower(model: *mut Clp_Simplex, rowLower: *const f64);
}
extern "C" {
    #[doc = " Change row upper bounds"]
    pub fn Clp_chgRowUpper(model: *mut Clp_Simplex, rowUpper: *const f64);
}
extern "C" {
    #[doc = " Change column lower bounds"]
    pub fn Clp_chgColumnLower(model: *mut Clp_Simplex, columnLower: *const f64);
}
extern "C" {
    #[doc = " Change column upper bounds"]
    pub fn Clp_chgColumnUpper(model: *mut Clp_Simplex, columnUpper: *const f64);
}
extern "C" {
    #[doc = " Change objective coefficients"]
    pub fn Clp_chgObjCoefficients(model: *mut Clp_Simplex, objIn: *const f64);
}
extern "C" {
    pub fn Clp_modifyCoefficient(
        model: *mut Clp_Simplex,
        row: ::std::os::raw::c_int,
        column: ::std::os::raw::c_int,
        newElement: f64,
        keepZero: bool,
    );
}
extern "C" {
    #[doc = " Drops names - makes lengthnames 0 and names empty"]
    pub fn Clp_dropNames(model: *mut Clp_Simplex);
}
extern "C" {
    #[doc = " Copies in names"]
    pub fn Clp_copyNames(
        model: *mut Clp_Simplex,
        rowNames: *const *const ::std::os::raw::c_char,
        columnNames: *const *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Number of rows"]
    pub fn Clp_numberRows(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Number of columns"]
    pub fn Clp_numberColumns(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Primal tolerance to use"]
    pub fn Clp_primalTolerance(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setPrimalTolerance(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Dual tolerance to use"]
    pub fn Clp_dualTolerance(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setDualTolerance(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Dual objective limit"]
    pub fn Clp_dualObjectiveLimit(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setDualObjectiveLimit(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Objective offset"]
    pub fn Clp_objectiveOffset(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setObjectiveOffset(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Fills in array with problem name"]
    pub fn Clp_problemName(
        model: *mut Clp_Simplex,
        maxNumberCharacters: ::std::os::raw::c_int,
        array: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn Clp_setProblemName(
        model: *mut Clp_Simplex,
        maxNumberCharacters: ::std::os::raw::c_int,
        array: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Number of iterations"]
    pub fn Clp_numberIterations(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Clp_setNumberIterations(model: *mut Clp_Simplex, numberIterations: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Maximum number of iterations"]
    pub fn maximumIterations(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Clp_setMaximumIterations(model: *mut Clp_Simplex, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Maximum time in seconds (from when set called)"]
    pub fn Clp_maximumSeconds(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setMaximumSeconds(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Returns true if hit maximum iterations (or time)"]
    pub fn Clp_hitMaximumIterations(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Status of problem:\n0 - optimal\n1 - primal infeasible\n2 - dual infeasible\n3 - stopped on iterations etc\n4 - stopped due to errors"]
    pub fn Clp_status(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set problem status"]
    pub fn Clp_setProblemStatus(model: *mut Clp_Simplex, problemStatus: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Secondary status of problem - may get extended\n0 - none\n1 - primal infeasible because dual limit reached\n2 - scaled problem optimal - unscaled has primal infeasibilities\n3 - scaled problem optimal - unscaled has dual infeasibilities\n4 - scaled problem optimal - unscaled has both dual and primal infeasibilities"]
    pub fn Clp_secondaryStatus(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Clp_setSecondaryStatus(model: *mut Clp_Simplex, status: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore"]
    pub fn Clp_optimizationDirection(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setOptimizationDirection(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Primal row solution"]
    pub fn Clp_primalRowSolution(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Primal column solution"]
    pub fn Clp_primalColumnSolution(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Dual row solution"]
    pub fn Clp_dualRowSolution(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Reduced costs"]
    pub fn Clp_dualColumnSolution(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Row lower"]
    pub fn Clp_rowLower(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Row upper"]
    pub fn Clp_rowUpper(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Objective"]
    pub fn Clp_objective(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Column Lower"]
    pub fn Clp_columnLower(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Column Upper"]
    pub fn Clp_columnUpper(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Number of elements in matrix"]
    pub fn Clp_getNumElements(model: *mut Clp_Simplex) -> CoinBigIndex;
}
extern "C" {
    pub fn Clp_getVectorStarts(model: *mut Clp_Simplex) -> *const CoinBigIndex;
}
extern "C" {
    pub fn Clp_getIndices(model: *mut Clp_Simplex) -> *const ::std::os::raw::c_int;
}
extern "C" {
    pub fn Clp_getVectorLengths(model: *mut Clp_Simplex) -> *const ::std::os::raw::c_int;
}
extern "C" {
    pub fn Clp_getElements(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Objective value"]
    pub fn Clp_objectiveValue(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[doc = " Integer information"]
    pub fn Clp_integerInformation(model: *mut Clp_Simplex) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gives Infeasibility ray.\n\n Use Clp_freeRay to free the returned array.\n\n @return infeasibility ray, or NULL returned if none/wrong."]
    pub fn Clp_infeasibilityRay(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Gives ray in which the problem is unbounded.\n\n Use Clp_freeRay to free the returned array.\n\n @return unbounded ray, or NULL returned if none/wrong."]
    pub fn Clp_unboundedRay(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Frees a infeasibility or unbounded ray."]
    pub fn Clp_freeRay(model: *mut Clp_Simplex, ray: *mut f64);
}
extern "C" {
    #[doc = " See if status array exists (partly for OsiClp)"]
    pub fn Clp_statusExists(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return address of status array (char[numberRows+numberColumns])"]
    pub fn Clp_statusArray(model: *mut Clp_Simplex) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " Copy in status vector"]
    pub fn Clp_copyinStatus(model: *mut Clp_Simplex, statusArray: *const ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn Clp_getColumnStatus(model: *mut Clp_Simplex, sequence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Clp_getRowStatus(model: *mut Clp_Simplex, sequence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Clp_setColumnStatus(model: *mut Clp_Simplex, sequence: ::std::os::raw::c_int, value: ::std::os::raw::c_int);
}
extern "C" {
    pub fn Clp_setRowStatus(model: *mut Clp_Simplex, sequence: ::std::os::raw::c_int, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " User pointer for whatever reason"]
    pub fn Clp_setUserPointer(model: *mut Clp_Simplex, pointer: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn Clp_getUserPointer(model: *mut Clp_Simplex) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Pass in Callback function.\nMessage numbers up to 1000000 are Clp, Coin ones have 1000000 added"]
    pub fn Clp_registerCallBack(model: *mut Clp_Simplex, userCallBack: clp_callback);
}
extern "C" {
    #[doc = " Unset Callback function"]
    pub fn Clp_clearCallBack(model: *mut Clp_Simplex);
}
extern "C" {
    #[doc = " Amount of print out:\n0 - none\n1 - just final\n2 - just factorizations\n3 - as 2 plus a bit more\n4 - verbose\nabove that 8,16,32 etc just for selective debug"]
    pub fn Clp_setLogLevel(model: *mut Clp_Simplex, value: ::std::os::raw::c_int);
}
extern "C" {
    pub fn Clp_logLevel(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " length of names (0 means no names0"]
    pub fn Clp_lengthNames(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill in array (at least lengthNames+1 long) with a row name"]
    pub fn Clp_rowName(model: *mut Clp_Simplex, iRow: ::std::os::raw::c_int, name: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Fill in array (at least lengthNames+1 long) with a column name"]
    pub fn Clp_columnName(model: *mut Clp_Simplex, iColumn: ::std::os::raw::c_int, name: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set row name - Nice if they are short - 8 chars or less I think"]
    pub fn Clp_setRowName(model: *mut Clp_Simplex, iRow: ::std::os::raw::c_int, name: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set column name - Nice if they are short - 8 chars or less I think"]
    pub fn Clp_setColumnName(
        model: *mut Clp_Simplex,
        iColumn: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " General solve algorithm which can do presolve.\nSee  ClpSolve.hpp for options"]
    pub fn Clp_initialSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pass solve options. (Exception to direct analogue rule)"]
    pub fn Clp_initialSolveWithOptions(model: *mut Clp_Simplex, arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dual initial solve"]
    pub fn Clp_initialDualSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Primal initial solve"]
    pub fn Clp_initialPrimalSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Barrier initial solve"]
    pub fn Clp_initialBarrierSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Barrier initial solve, no crossover"]
    pub fn Clp_initialBarrierNoCrossSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dual algorithm - see ClpSimplexDual.hpp for method"]
    pub fn Clp_dual(model: *mut Clp_Simplex, ifValuesPass: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Primal algorithm - see ClpSimplexPrimal.hpp for method"]
    pub fn Clp_primal(model: *mut Clp_Simplex, ifValuesPass: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Solve the problem with the idiot code"]
    pub fn Clp_idiot(model: *mut Clp_Simplex, tryhard: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Sets or unsets scaling, 0 -off, 1 equilibrium, 2 geometric, 3, auto, 4 dynamic(later)"]
    pub fn Clp_scaling(model: *mut Clp_Simplex, mode: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Gets scalingFlag"]
    pub fn Clp_scalingFlag(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Crash - at present just aimed at dual, returns\n-2 if dual preferred and crash basis created\n-1 if dual preferred and all slack basis preferred\n0 if basis going in was not all slack\n1 if primal preferred and all slack basis preferred\n2 if primal preferred and crash basis created.\n\nif gap between bounds <=\"gap\" variables can be flipped\n\nIf \"pivot\" is\n0 No pivoting (so will just be choice of algorithm)\n1 Simple pivoting e.g. gub\n2 Mini iterations"]
    pub fn Clp_crash(model: *mut Clp_Simplex, gap: f64, pivot: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If problem is primal feasible"]
    pub fn Clp_primalFeasible(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If problem is dual feasible"]
    pub fn Clp_dualFeasible(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dual bound"]
    pub fn Clp_dualBound(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setDualBound(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Infeasibility cost"]
    pub fn Clp_infeasibilityCost(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setInfeasibilityCost(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Perturbation:\n50  - switch on perturbation\n100 - auto perturb if takes too long (1.0e-6 largest nonzero)\n101 - we are perturbed\n102 - don't try perturbing again\ndefault is 100\nothers are for playing"]
    pub fn Clp_perturbation(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Clp_setPerturbation(model: *mut Clp_Simplex, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Current (or last) algorithm"]
    pub fn Clp_algorithm(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set algorithm"]
    pub fn Clp_setAlgorithm(model: *mut Clp_Simplex, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Sum of dual infeasibilities"]
    pub fn Clp_sumDualInfeasibilities(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[doc = " Number of dual infeasibilities"]
    pub fn Clp_numberDualInfeasibilities(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sum of primal infeasibilities"]
    pub fn Clp_sumPrimalInfeasibilities(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[doc = " Number of primal infeasibilities"]
    pub fn Clp_numberPrimalInfeasibilities(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Save model to file, returns 0 if success.  This is designed for\nuse outside algorithms so does not save iterating arrays etc.\nIt does not save any messaging information.\nDoes not save scaling values.\nIt does not know about all types of virtual functions."]
    pub fn Clp_saveModel(model: *mut Clp_Simplex, fileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Restore model from file, returns 0 if success,\ndeletes current model"]
    pub fn Clp_restoreModel(model: *mut Clp_Simplex, fileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Just check solution (for external use) - sets sum of\ninfeasibilities etc"]
    pub fn Clp_checkSolution(model: *mut Clp_Simplex);
}
extern "C" {
    #[doc = " Number of rows"]
    pub fn Clp_getNumRows(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Number of columns"]
    pub fn Clp_getNumCols(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Number of iterations"]
    pub fn Clp_getIterationCount(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Are there a numerical difficulties?"]
    pub fn Clp_isAbandoned(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is optimality proven?"]
    pub fn Clp_isProvenOptimal(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is primal infeasiblity proven?"]
    pub fn Clp_isProvenPrimalInfeasible(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is dual infeasiblity proven?"]
    pub fn Clp_isProvenDualInfeasible(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is the given primal objective limit reached?"]
    pub fn Clp_isPrimalObjectiveLimitReached(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is the given dual objective limit reached?"]
    pub fn Clp_isDualObjectiveLimitReached(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iteration limit reached?"]
    pub fn Clp_isIterationLimitReached(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore"]
    pub fn Clp_getObjSense(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[doc = " Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore"]
    pub fn Clp_setObjSense(model: *mut Clp_Simplex, objsen: f64);
}
extern "C" {
    #[doc = " Primal row solution"]
    pub fn Clp_getRowActivity(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Primal column solution"]
    pub fn Clp_getColSolution(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    pub fn Clp_setColSolution(model: *mut Clp_Simplex, input: *const f64);
}
extern "C" {
    #[doc = " Dual row solution"]
    pub fn Clp_getRowPrice(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Reduced costs"]
    pub fn Clp_getReducedCost(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Row lower"]
    pub fn Clp_getRowLower(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Row upper"]
    pub fn Clp_getRowUpper(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Objective"]
    pub fn Clp_getObjCoefficients(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Column Lower"]
    pub fn Clp_getColLower(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Column Upper"]
    pub fn Clp_getColUpper(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Objective value"]
    pub fn Clp_getObjValue(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[doc = " Print model for debugging purposes"]
    pub fn Clp_printModel(model: *mut Clp_Simplex, prefix: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn Clp_getSmallElementValue(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setSmallElementValue(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    pub fn ClpSolve_setSpecialOption(
        arg1: *mut Clp_Solve,
        which: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
        extraInfo: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ClpSolve_getSpecialOption(arg1: *mut Clp_Solve, which: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " method: (see ClpSolve::SolveType)\n0 - dual simplex\n1 - primal simplex\n2 - primal or sprint\n3 - barrier\n4 - barrier no crossover\n5 - automatic\n6 - not implemented\n-- pass extraInfo == -1 for default behavior"]
    pub fn ClpSolve_setSolveType(arg1: *mut Clp_Solve, method: ::std::os::raw::c_int, extraInfo: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_getSolveType(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " amount: (see ClpSolve::PresolveType)\n0 - presolve on\n1 - presolve off\n2 - presolve number\n3 - presolve number cost\n-- pass extraInfo == -1 for default behavior"]
    pub fn ClpSolve_setPresolveType(
        arg1: *mut Clp_Solve,
        amount: ::std::os::raw::c_int,
        extraInfo: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ClpSolve_getPresolveType(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_getPresolvePasses(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_getExtraInfo(arg1: *mut Clp_Solve, which: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setInfeasibleReturn(arg1: *mut Clp_Solve, trueFalse: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_infeasibleReturn(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_doDual(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoDual(arg1: *mut Clp_Solve, doDual: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doSingleton(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoSingleton(arg1: *mut Clp_Solve, doSingleton: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doDoubleton(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoDoubleton(arg1: *mut Clp_Solve, doDoubleton: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doTripleton(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoTripleton(arg1: *mut Clp_Solve, doTripleton: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doTighten(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoTighten(arg1: *mut Clp_Solve, doTighten: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doForcing(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoForcing(arg1: *mut Clp_Solve, doForcing: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doImpliedFree(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoImpliedFree(arg1: *mut Clp_Solve, doImpliedFree: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doDupcol(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoDupcol(arg1: *mut Clp_Solve, doDupcol: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doDuprow(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoDuprow(arg1: *mut Clp_Solve, doDuprow: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doSingletonColumn(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoSingletonColumn(arg1: *mut Clp_Solve, doSingleton: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_presolveActions(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setPresolveActions(arg1: *mut Clp_Solve, action: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_substitution(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setSubstitution(arg1: *mut Clp_Solve, value: ::std::os::raw::c_int);
}
