/* automatically generated by rust-bindgen 0.57.0 */

pub const CLP_VERSION: &[u8; 6usize] = b"trunk\0";
pub const CLP_VERSION_MAJOR: u32 = 9999;
pub const CLP_VERSION_MINOR: u32 = 9999;
pub const CLP_VERSION_RELEASE: u32 = 9999;
pub const COINUTILS_VERSION: &[u8; 7usize] = b"master\0";
pub const COINUTILS_VERSION_MAJOR: u32 = 9999;
pub const COINUTILS_VERSION_MINOR: u32 = 9999;
pub const COINUTILS_VERSION_RELEASE: u32 = 9999;
pub const COINUTILS_BIGINDEX_IS_INT: u32 = 1;
pub const COINUTILS_CPLUSPLUS11: u32 = 1;
pub const COINUTILS_HAS_CSTDINT: u32 = 1;
pub const COINUTILS_HAS_STDINT_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 32;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const COIN_BIG_DOUBLE: u32 = 0;
pub const COIN_LONG_WORK: u32 = 0;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__fsid_t), "::", stringify!(__val))
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type CoinBigIndex = ::std::os::raw::c_int;
pub type CoinByteArray = isize;
pub type CoinWorkDouble = f64;
#[doc = " For factorizations inheriting from CoinDenseFactorization -"]
#[doc = "leave partial conversions but back to double."]
pub type CoinFactorizationDouble2 = f64;
pub type CoinFactorizationDouble = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Clp_Simplex_s {
    _unused: [u8; 0],
}
pub type Clp_Simplex = Clp_Simplex_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Clp_Solve_s {
    _unused: [u8; 0],
}
pub type Clp_Solve = Clp_Solve_s;
#[doc = " typedef for user call back."]
#[doc = ""]
#[doc = " The cvec are constructed so don't need to be const"]
pub type clp_callback = ::std::option::Option<
    unsafe extern "C" fn(
        model: *mut Clp_Simplex,
        msgno: ::std::os::raw::c_int,
        ndouble: ::std::os::raw::c_int,
        dvec: *const f64,
        nint: ::std::os::raw::c_int,
        ivec: *const CoinBigIndex,
        nchar: ::std::os::raw::c_int,
        cvec: *mut *mut ::std::os::raw::c_char,
    ),
>;
extern "C" {
    #[doc = " Clp library version number as string."]
    pub fn Clp_Version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Major number of Clp library version."]
    pub fn Clp_VersionMajor() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Minor number of Clp library version."]
    pub fn Clp_VersionMinor() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release number of Clp library version."]
    pub fn Clp_VersionRelease() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Default constructor"]
    pub fn Clp_newModel() -> *mut Clp_Simplex;
}
extern "C" {
    #[doc = " Destructor"]
    pub fn Clp_deleteModel(model: *mut Clp_Simplex);
}
extern "C" {
    #[doc = " Default constructor"]
    pub fn ClpSolve_new() -> *mut Clp_Solve;
}
extern "C" {
    #[doc = " Destructor"]
    pub fn ClpSolve_delete(solve: *mut Clp_Solve);
}
extern "C" {
    #[doc = " Loads a problem (the constraints on the"]
    #[doc = "rows are given by lower and upper bounds). If a pointer is NULL then the"]
    #[doc = "following values are the default:"]
    #[doc = "<ul>"]
    #[doc = "<li> <code>colub</code>: all columns have upper bound infinity"]
    #[doc = "<li> <code>collb</code>: all columns have lower bound 0"]
    #[doc = "<li> <code>rowub</code>: all rows have upper bound infinity"]
    #[doc = "<li> <code>rowlb</code>: all rows have lower bound -infinity"]
    #[doc = "<li> <code>obj</code>: all variables have 0 objective coefficient"]
    #[doc = "</ul>"]
    #[doc = "given in a standard column major ordered format (without gaps)."]
    pub fn Clp_loadProblem(
        model: *mut Clp_Simplex,
        numcols: ::std::os::raw::c_int,
        numrows: ::std::os::raw::c_int,
        start: *const CoinBigIndex,
        index: *const ::std::os::raw::c_int,
        value: *const f64,
        collb: *const f64,
        colub: *const f64,
        obj: *const f64,
        rowlb: *const f64,
        rowub: *const f64,
    );
}
extern "C" {
    pub fn Clp_loadQuadraticObjective(
        model: *mut Clp_Simplex,
        numberColumns: ::std::os::raw::c_int,
        start: *const CoinBigIndex,
        column: *const ::std::os::raw::c_int,
        element: *const f64,
    );
}
extern "C" {
    #[doc = " Read an mps file from the given filename"]
    pub fn Clp_readMps(
        model: *mut Clp_Simplex,
        filename: *const ::std::os::raw::c_char,
        keepNames: ::std::os::raw::c_int,
        ignoreErrors: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write an mps file to the given filename */"]
    #[doc = "Number across is 1 or 2."]
    #[doc = "Use objSense = -1D to flip the objective function around."]
    pub fn Clp_writeMps(
        model: *mut Clp_Simplex,
        filename: *const ::std::os::raw::c_char,
        formatType: ::std::os::raw::c_int,
        numberAcross: ::std::os::raw::c_int,
        objSense: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy in integer informations"]
    pub fn Clp_copyInIntegerInformation(model: *mut Clp_Simplex, information: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Drop integer informations"]
    pub fn Clp_deleteIntegerInformation(model: *mut Clp_Simplex);
}
extern "C" {
    #[doc = " Resizes rim part of model"]
    pub fn Clp_resize(
        model: *mut Clp_Simplex,
        newNumberRows: ::std::os::raw::c_int,
        newNumberColumns: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Deletes rows"]
    pub fn Clp_deleteRows(model: *mut Clp_Simplex, number: ::std::os::raw::c_int, which: *const ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Add rows"]
    pub fn Clp_addRows(
        model: *mut Clp_Simplex,
        number: ::std::os::raw::c_int,
        rowLower: *const f64,
        rowUpper: *const f64,
        rowStarts: *const CoinBigIndex,
        columns: *const ::std::os::raw::c_int,
        elements: *const f64,
    );
}
extern "C" {
    #[doc = " Deletes columns"]
    pub fn Clp_deleteColumns(
        model: *mut Clp_Simplex,
        number: ::std::os::raw::c_int,
        which: *const ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Add columns"]
    pub fn Clp_addColumns(
        model: *mut Clp_Simplex,
        number: ::std::os::raw::c_int,
        columnLower: *const f64,
        columnUpper: *const f64,
        objective: *const f64,
        columnStarts: *const CoinBigIndex,
        rows: *const ::std::os::raw::c_int,
        elements: *const f64,
    );
}
extern "C" {
    #[doc = " Change row lower bounds"]
    pub fn Clp_chgRowLower(model: *mut Clp_Simplex, rowLower: *const f64);
}
extern "C" {
    #[doc = " Change row upper bounds"]
    pub fn Clp_chgRowUpper(model: *mut Clp_Simplex, rowUpper: *const f64);
}
extern "C" {
    #[doc = " Change column lower bounds"]
    pub fn Clp_chgColumnLower(model: *mut Clp_Simplex, columnLower: *const f64);
}
extern "C" {
    #[doc = " Change column upper bounds"]
    pub fn Clp_chgColumnUpper(model: *mut Clp_Simplex, columnUpper: *const f64);
}
extern "C" {
    #[doc = " Change objective coefficients"]
    pub fn Clp_chgObjCoefficients(model: *mut Clp_Simplex, objIn: *const f64);
}
extern "C" {
    #[doc = " Change matrix coefficients"]
    pub fn Clp_modifyCoefficient(
        model: *mut Clp_Simplex,
        row: ::std::os::raw::c_int,
        column: ::std::os::raw::c_int,
        newElement: f64,
        keepZero: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Drops names - makes lengthnames 0 and names empty"]
    pub fn Clp_dropNames(model: *mut Clp_Simplex);
}
extern "C" {
    #[doc = " Copies in names"]
    pub fn Clp_copyNames(
        model: *mut Clp_Simplex,
        rowNames: *const *const ::std::os::raw::c_char,
        columnNames: *const *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " The underlying ClpSimplex model"]
    pub fn Clp_model(model: *mut Clp_Simplex) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Number of rows"]
    pub fn Clp_numberRows(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Number of columns"]
    pub fn Clp_numberColumns(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Primal tolerance to use"]
    pub fn Clp_primalTolerance(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setPrimalTolerance(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Dual tolerance to use"]
    pub fn Clp_dualTolerance(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setDualTolerance(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Dual objective limit"]
    pub fn Clp_dualObjectiveLimit(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setDualObjectiveLimit(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Objective offset"]
    pub fn Clp_objectiveOffset(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setObjectiveOffset(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Fills in array with problem name"]
    pub fn Clp_problemName(
        model: *mut Clp_Simplex,
        maxNumberCharacters: ::std::os::raw::c_int,
        array: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn Clp_setProblemName(
        model: *mut Clp_Simplex,
        maxNumberCharacters: ::std::os::raw::c_int,
        array: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Number of iterations"]
    pub fn Clp_numberIterations(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Clp_setNumberIterations(model: *mut Clp_Simplex, numberIterations: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Maximum number of iterations"]
    pub fn Clp_maximumIterations(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Clp_setMaximumIterations(model: *mut Clp_Simplex, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Maximum time in seconds (from when set called)"]
    pub fn Clp_maximumSeconds(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setMaximumSeconds(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Returns true if hit maximum iterations (or time)"]
    pub fn Clp_hitMaximumIterations(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Status of problem:"]
    #[doc = "0 - optimal"]
    #[doc = "1 - primal infeasible"]
    #[doc = "2 - dual infeasible"]
    #[doc = "3 - stopped on iterations etc"]
    #[doc = "4 - stopped due to errors"]
    pub fn Clp_status(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set problem status"]
    pub fn Clp_setProblemStatus(model: *mut Clp_Simplex, problemStatus: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Secondary status of problem - may get extended"]
    #[doc = "0 - none"]
    #[doc = "1 - primal infeasible because dual limit reached"]
    #[doc = "2 - scaled problem optimal - unscaled has primal infeasibilities"]
    #[doc = "3 - scaled problem optimal - unscaled has dual infeasibilities"]
    #[doc = "4 - scaled problem optimal - unscaled has both dual and primal infeasibilities"]
    pub fn Clp_secondaryStatus(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Clp_setSecondaryStatus(model: *mut Clp_Simplex, status: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore"]
    pub fn Clp_optimizationDirection(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setOptimizationDirection(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Primal row solution"]
    pub fn Clp_primalRowSolution(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Primal column solution"]
    pub fn Clp_primalColumnSolution(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Dual row solution"]
    pub fn Clp_dualRowSolution(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Reduced costs"]
    pub fn Clp_dualColumnSolution(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Row lower"]
    pub fn Clp_rowLower(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Row upper"]
    pub fn Clp_rowUpper(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Objective"]
    pub fn Clp_objective(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Column Lower"]
    pub fn Clp_columnLower(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Column Upper"]
    pub fn Clp_columnUpper(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Number of elements in matrix"]
    pub fn Clp_getNumElements(model: *mut Clp_Simplex) -> CoinBigIndex;
}
extern "C" {
    pub fn Clp_getVectorStarts(model: *mut Clp_Simplex) -> *const CoinBigIndex;
}
extern "C" {
    pub fn Clp_getIndices(model: *mut Clp_Simplex) -> *const ::std::os::raw::c_int;
}
extern "C" {
    pub fn Clp_getVectorLengths(model: *mut Clp_Simplex) -> *const ::std::os::raw::c_int;
}
extern "C" {
    pub fn Clp_getElements(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Objective value"]
    pub fn Clp_objectiveValue(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[doc = " Integer information"]
    pub fn Clp_integerInformation(model: *mut Clp_Simplex) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gives Infeasibility ray."]
    #[doc = ""]
    #[doc = " Use Clp_freeRay to free the returned array."]
    #[doc = ""]
    #[doc = " @return infeasibility ray, or NULL returned if none/wrong."]
    pub fn Clp_infeasibilityRay(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Gives ray in which the problem is unbounded."]
    #[doc = ""]
    #[doc = " Use Clp_freeRay to free the returned array."]
    #[doc = ""]
    #[doc = " @return unbounded ray, or NULL returned if none/wrong."]
    pub fn Clp_unboundedRay(model: *mut Clp_Simplex) -> *mut f64;
}
extern "C" {
    #[doc = " Frees a infeasibility or unbounded ray."]
    pub fn Clp_freeRay(model: *mut Clp_Simplex, ray: *mut f64);
}
extern "C" {
    #[doc = " See if status array exists (partly for OsiClp)"]
    pub fn Clp_statusExists(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return address of status array (char[numberRows+numberColumns])"]
    pub fn Clp_statusArray(model: *mut Clp_Simplex) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " Copy in status vector"]
    pub fn Clp_copyinStatus(model: *mut Clp_Simplex, statusArray: *const ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn Clp_getColumnStatus(model: *mut Clp_Simplex, sequence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Clp_getRowStatus(model: *mut Clp_Simplex, sequence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Clp_setColumnStatus(model: *mut Clp_Simplex, sequence: ::std::os::raw::c_int, value: ::std::os::raw::c_int);
}
extern "C" {
    pub fn Clp_setRowStatus(model: *mut Clp_Simplex, sequence: ::std::os::raw::c_int, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " User pointer for whatever reason"]
    pub fn Clp_setUserPointer(model: *mut Clp_Simplex, pointer: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn Clp_getUserPointer(model: *mut Clp_Simplex) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Pass in Callback function."]
    #[doc = "Message numbers up to 1000000 are Clp, Coin ones have 1000000 added"]
    pub fn Clp_registerCallBack(model: *mut Clp_Simplex, userCallBack: clp_callback);
}
extern "C" {
    #[doc = " Unset Callback function"]
    pub fn Clp_clearCallBack(model: *mut Clp_Simplex);
}
extern "C" {
    #[doc = " Amount of print out:"]
    #[doc = "0 - none"]
    #[doc = "1 - just final"]
    #[doc = "2 - just factorizations"]
    #[doc = "3 - as 2 plus a bit more"]
    #[doc = "4 - verbose"]
    #[doc = "above that 8,16,32 etc just for selective debug"]
    pub fn Clp_setLogLevel(model: *mut Clp_Simplex, value: ::std::os::raw::c_int);
}
extern "C" {
    pub fn Clp_logLevel(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " length of names (0 means no names0"]
    pub fn Clp_lengthNames(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill in array (at least lengthNames+1 long) with a row name"]
    pub fn Clp_rowName(model: *mut Clp_Simplex, iRow: ::std::os::raw::c_int, name: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Fill in array (at least lengthNames+1 long) with a column name"]
    pub fn Clp_columnName(model: *mut Clp_Simplex, iColumn: ::std::os::raw::c_int, name: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set row name - Nice if they are short - 8 chars or less I think"]
    pub fn Clp_setRowName(model: *mut Clp_Simplex, iRow: ::std::os::raw::c_int, name: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set column name - Nice if they are short - 8 chars or less I think"]
    pub fn Clp_setColumnName(
        model: *mut Clp_Simplex,
        iColumn: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " General solve algorithm which can do presolve."]
    #[doc = "See  ClpSolve.hpp for options"]
    pub fn Clp_initialSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pass solve options. (Exception to direct analogue rule)"]
    pub fn Clp_initialSolveWithOptions(model: *mut Clp_Simplex, arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dual initial solve"]
    pub fn Clp_initialDualSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Primal initial solve"]
    pub fn Clp_initialPrimalSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Barrier initial solve"]
    pub fn Clp_initialBarrierSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Barrier initial solve, no crossover"]
    pub fn Clp_initialBarrierNoCrossSolve(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dual algorithm - see ClpSimplexDual.hpp for method"]
    pub fn Clp_dual(model: *mut Clp_Simplex, ifValuesPass: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Primal algorithm - see ClpSimplexPrimal.hpp for method"]
    pub fn Clp_primal(model: *mut Clp_Simplex, ifValuesPass: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Solve the problem with the idiot code"]
    pub fn Clp_idiot(model: *mut Clp_Simplex, tryhard: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Sets or unsets scaling, 0 -off, 1 equilibrium, 2 geometric, 3, auto, 4 dynamic(later)"]
    pub fn Clp_scaling(model: *mut Clp_Simplex, mode: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Gets scalingFlag"]
    pub fn Clp_scalingFlag(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Crash - at present just aimed at dual, returns"]
    #[doc = "-2 if dual preferred and crash basis created"]
    #[doc = "-1 if dual preferred and all slack basis preferred"]
    #[doc = "0 if basis going in was not all slack"]
    #[doc = "1 if primal preferred and all slack basis preferred"]
    #[doc = "2 if primal preferred and crash basis created."]
    #[doc = ""]
    #[doc = "if gap between bounds <=\"gap\" variables can be flipped"]
    #[doc = ""]
    #[doc = "If \"pivot\" is"]
    #[doc = "0 No pivoting (so will just be choice of algorithm)"]
    #[doc = "1 Simple pivoting e.g. gub"]
    #[doc = "2 Mini iterations"]
    pub fn Clp_crash(model: *mut Clp_Simplex, gap: f64, pivot: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If problem is primal feasible"]
    pub fn Clp_primalFeasible(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If problem is dual feasible"]
    pub fn Clp_dualFeasible(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dual bound"]
    pub fn Clp_dualBound(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setDualBound(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Infeasibility cost"]
    pub fn Clp_infeasibilityCost(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setInfeasibilityCost(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    #[doc = " Perturbation:"]
    #[doc = "50  - switch on perturbation"]
    #[doc = "100 - auto perturb if takes too long (1.0e-6 largest nonzero)"]
    #[doc = "101 - we are perturbed"]
    #[doc = "102 - don't try perturbing again"]
    #[doc = "default is 100"]
    #[doc = "others are for playing"]
    pub fn Clp_perturbation(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Clp_setPerturbation(model: *mut Clp_Simplex, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Current (or last) algorithm"]
    pub fn Clp_algorithm(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set algorithm"]
    pub fn Clp_setAlgorithm(model: *mut Clp_Simplex, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Sum of dual infeasibilities"]
    pub fn Clp_sumDualInfeasibilities(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[doc = " Number of dual infeasibilities"]
    pub fn Clp_numberDualInfeasibilities(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sum of primal infeasibilities"]
    pub fn Clp_sumPrimalInfeasibilities(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[doc = " Number of primal infeasibilities"]
    pub fn Clp_numberPrimalInfeasibilities(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Save model to file, returns 0 if success.  This is designed for"]
    #[doc = "use outside algorithms so does not save iterating arrays etc."]
    #[doc = "It does not save any messaging information."]
    #[doc = "Does not save scaling values."]
    #[doc = "It does not know about all types of virtual functions."]
    pub fn Clp_saveModel(model: *mut Clp_Simplex, fileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Restore model from file, returns 0 if success,"]
    #[doc = "deletes current model"]
    pub fn Clp_restoreModel(model: *mut Clp_Simplex, fileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Just check solution (for external use) - sets sum of"]
    #[doc = "infeasibilities etc"]
    pub fn Clp_checkSolution(model: *mut Clp_Simplex);
}
extern "C" {
    #[doc = " Number of rows"]
    pub fn Clp_getNumRows(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Number of columns"]
    pub fn Clp_getNumCols(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Number of iterations"]
    pub fn Clp_getIterationCount(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Are there a numerical difficulties?"]
    pub fn Clp_isAbandoned(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is optimality proven?"]
    pub fn Clp_isProvenOptimal(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is primal infeasiblity proven?"]
    pub fn Clp_isProvenPrimalInfeasible(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is dual infeasiblity proven?"]
    pub fn Clp_isProvenDualInfeasible(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is the given primal objective limit reached?"]
    pub fn Clp_isPrimalObjectiveLimitReached(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is the given dual objective limit reached?"]
    pub fn Clp_isDualObjectiveLimitReached(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iteration limit reached?"]
    pub fn Clp_isIterationLimitReached(model: *mut Clp_Simplex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore"]
    pub fn Clp_getObjSense(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[doc = " Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore"]
    pub fn Clp_setObjSense(model: *mut Clp_Simplex, objsen: f64);
}
extern "C" {
    #[doc = " Primal row solution"]
    pub fn Clp_getRowActivity(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Primal column solution"]
    pub fn Clp_getColSolution(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    pub fn Clp_setColSolution(model: *mut Clp_Simplex, input: *const f64);
}
extern "C" {
    #[doc = " Dual row solution"]
    pub fn Clp_getRowPrice(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Reduced costs"]
    pub fn Clp_getReducedCost(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Row lower"]
    pub fn Clp_getRowLower(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Row upper"]
    pub fn Clp_getRowUpper(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Objective"]
    pub fn Clp_getObjCoefficients(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Column Lower"]
    pub fn Clp_getColLower(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Column Upper"]
    pub fn Clp_getColUpper(model: *mut Clp_Simplex) -> *const f64;
}
extern "C" {
    #[doc = " Objective value"]
    pub fn Clp_getObjValue(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    #[doc = " Set random seed"]
    pub fn Clp_setRandomSeed(model: *mut Clp_Simplex, seed: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Print model for debugging purposes"]
    pub fn Clp_printModel(model: *mut Clp_Simplex, prefix: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn Clp_getSmallElementValue(model: *mut Clp_Simplex) -> f64;
}
extern "C" {
    pub fn Clp_setSmallElementValue(model: *mut Clp_Simplex, value: f64);
}
extern "C" {
    pub fn ClpSolve_setSpecialOption(
        arg1: *mut Clp_Solve,
        which: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
        extraInfo: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ClpSolve_getSpecialOption(arg1: *mut Clp_Solve, which: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " method: (see ClpSolve::SolveType)"]
    #[doc = "0 - dual simplex"]
    #[doc = "1 - primal simplex"]
    #[doc = "2 - primal or sprint"]
    #[doc = "3 - barrier"]
    #[doc = "4 - barrier no crossover"]
    #[doc = "5 - automatic"]
    #[doc = "6 - not implemented"]
    #[doc = "-- pass extraInfo == -1 for default behavior"]
    pub fn ClpSolve_setSolveType(arg1: *mut Clp_Solve, method: ::std::os::raw::c_int, extraInfo: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_getSolveType(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " amount: (see ClpSolve::PresolveType)"]
    #[doc = "0 - presolve on"]
    #[doc = "1 - presolve off"]
    #[doc = "2 - presolve number"]
    #[doc = "3 - presolve number cost"]
    #[doc = "-- pass extraInfo == -1 for default behavior"]
    pub fn ClpSolve_setPresolveType(
        arg1: *mut Clp_Solve,
        amount: ::std::os::raw::c_int,
        extraInfo: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ClpSolve_getPresolveType(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_getPresolvePasses(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_getExtraInfo(arg1: *mut Clp_Solve, which: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setInfeasibleReturn(arg1: *mut Clp_Solve, trueFalse: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_infeasibleReturn(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_doDual(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoDual(arg1: *mut Clp_Solve, doDual: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doSingleton(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoSingleton(arg1: *mut Clp_Solve, doSingleton: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doDoubleton(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoDoubleton(arg1: *mut Clp_Solve, doDoubleton: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doTripleton(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoTripleton(arg1: *mut Clp_Solve, doTripleton: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doTighten(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoTighten(arg1: *mut Clp_Solve, doTighten: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doForcing(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoForcing(arg1: *mut Clp_Solve, doForcing: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doImpliedFree(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoImpliedFree(arg1: *mut Clp_Solve, doImpliedFree: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doDupcol(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoDupcol(arg1: *mut Clp_Solve, doDupcol: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doDuprow(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoDuprow(arg1: *mut Clp_Solve, doDuprow: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_doSingletonColumn(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setDoSingletonColumn(arg1: *mut Clp_Solve, doSingleton: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_presolveActions(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setPresolveActions(arg1: *mut Clp_Solve, action: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ClpSolve_substitution(arg1: *mut Clp_Solve) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ClpSolve_setSubstitution(arg1: *mut Clp_Solve, value: ::std::os::raw::c_int);
}
